#!/usr/bin/python

# -*- coding: utf-8 -*-
"""
m5_stat

Created on Tue May 26 14:23:09 EDT 2015

@author: JJ Crosskey
"""
import sys
import argparse

## =================================================================
## argument parser
## =================================================================
parser = argparse.ArgumentParser(description="parse .m5 file and get alignment summary statistics",
                                 prog = 'm5_stat', #program name
                                 prefix_chars='-', # prefix for options
                                 fromfile_prefix_chars='@', # if options are read from file, '@args.txt'
                                 conflict_handler='resolve', # for handling conflict options
                                 add_help=True, # include help in the options
                                 formatter_class=argparse.ArgumentDefaultsHelpFormatter # print default values for options in help message
                                 )

## input files and directories
parser.add_argument("-i","--in",help="input .m5 file (generated by BLASR)",dest='m5File',required=True, type=argparse.FileType('r'))

## options
parser.add_argument("-m", "--minSeg", help="minimum length of the mapped query segment", dest="minSeg", default=1000, type=int)
parser.add_argument("-s", "--maxSub", help="maximum substitution rate", dest="maxSub", default=0.05, type=float)
parser.add_argument("-p", "--minPercent", help="percent of mapped length below which read is considered chimeric", dest="minPercent", default=0.95, type=float)

## output directory
parser.add_argument("-o","--out",help="output prefix",dest='outputPrefix', default="m5_stat", type=str)

## =================================================================
## parsing function
## =================================================================
def m5_stat(m5, minSeg, maxSub, minPercent, ref_stat, summary_stat):
    fields = m5.readline().strip("\n").split()
    query_dict = dict()
    ref_dict = dict()
    num_record = 0
    Total_bps = 0
    Total_maplen = 0
    Total_mismatch = 0
    Total_ins = 0
    Total_del = 0
    max_qlen = 0
    max_align_len = 0
    for line in m5:
        num_record += 1
        if num_record % 10000 == 0:
            sys.stderr.write("Scanned {} records\n".format(num_record))
        record_fields = line.strip("\n").split()
        qname = record_fields[0]
        map_len = int(record_fields[3]) - int(record_fields[2]) # mapped length of the segment
        ref = record_fields[5] # refname
        reflen = int(record_fields[6])
        if ref not in ref_dict:
            ref_dict[ref] = {'reflen': reflen, 'cov':[0]*reflen}
        rstart = int(record_fields[7])
        rend = int(record_fields[8])
        ref_map_len = rend - rstart + 1
        orientation = record_fields[9] # tstrand
        nummatch = int(record_fields[11])
        nummismatch = int(record_fields[12])
        numins = int(record_fields[13])
        numdel = int(record_fields[14])
        #map_dict = {'map_len':map_len, 'rstart':rstart, 'rend':rend, 'orientation':orientation, 'nummatch':nummatch, 'nummismatch':nummismatch,\
        #        'numins':numins, 'numdel':numdel}
        #query_dict[qname]['map'].append(map_dict)
        if ref_map_len > minSeg and nummismatch <= maxSub * map_len: # passes the threshold
            for i in xrange((rstart-1),rend):
                ref_dict[ref]['cov'][i] += 1
            qlen = int(record_fields[1])
            if qname not in query_dict:
                query_dict[qname] = {'qlen': qlen, 'chimeric':True} # initiate chimeric to True
                Total_bps += qlen
                max_qlen = (max_qlen if max_qlen > qlen else qlen)
                #query_dict[qname] = {'qlen': qlen, 'map':[], 'chimeric':True} # initiate chimeric to True
            if query_dict[qname]['chimeric'] is True and map_len > qlen * minPercent:
                query_dict[qname]['chimeric'] = False
            max_align_len = (max_align_len if max_align_len > map_len else map_len)
            Total_maplen += map_len
            Total_mismatch += nummismatch
            Total_ins += numins
            Total_del += numdel
    # for reference genomes/contigs
    ref_out = open(ref_stat,'w')
    ref_out.write("ref_name\tref_len\tcov_len\tcov_bps\n")
    for r in ref_dict:
        a = ref_dict[r]
        cov = a['cov']
        ref_out.write("{}\t{}\t{}\t{}\n".format(r, a['reflen'], a['reflen'] - cov.count(0), sum(cov)))
    ref_out.close()
    # statistics for the reads
    summary_out = open(summary_stat,'w')
    Total_chimeric = sum([ (1 if query_dict[key]['chimeric'] else 0) for key in query_dict ])
    summary_out.write("total bps\t{}\n".format(Total_bps))
    summary_out.write("mapped bps\t{}\n".format(Total_maplen))
    summary_out.write("mismatches\t{}\n".format(Total_mismatch))
    summary_out.write("ins\t{}\n".format(Total_ins))
    summary_out.write("del\t{}\n".format(Total_del))
    summary_out.write("chimeric contigs\t{}\n".format(Total_chimeric))
    summary_out.write("total # contigs\t{}\n".format(len(query_dict)))
    summary_out.write("Largest contig length\t{}\n".format(max_qlen))
    summary_out.write("Largest aligned contig length\t{}\n".format(max_align_len))
    summary_out.close()



## =================================================================
## main function
## =================================================================
def main(argv=None):
    
    if argv is None:
        args = parser.parse_args()
    ref_stat = args.outputPrefix+"_ref"
    summary_stat = args.outputPrefix + "_sum"
    m5_stat(args.m5File, args.minSeg, args.maxSub, args.minPercent, ref_stat, summary_stat)

##==============================================================
## call from command line (instead of interactively)
##==============================================================

if __name__ == '__main__':
    sys.exit(main())
